syntax = "proto3";

package graphql.gloo.solo.io;

option go_package = "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/graphql/v1alpha1";

option java_package = "io.envoyproxy.envoy.config.filter.http.graphql.v2";
option java_outer_classname = "GraphQLFilterProto";
option java_multiple_files = true;

import "extproto/ext.proto";
option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

import "github.com/solo-io/solo-kit/api/v1/metadata.proto";
import "github.com/solo-io/solo-kit/api/v1/status.proto";
import "github.com/solo-io/solo-kit/api/v1/solo-kit.proto";
import "github.com/solo-io/solo-kit/api/v1/ref.proto";

import "validate/validate.proto";

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";

// Defines a configuration for generating outgoing requests for a resolver.
message RequestTemplate {
  // Use this attribute to set request headers to your REST service. It consists of a
  // map of strings to value providers. The string key determines the name of the
  // resulting header, the value provided will be the value.
  //
  // at least need ":method" and ":path"
  map<string, string> headers = 1;

  // Use this attribute to set query parameters to your REST service. It consists of a
  // map of strings to value providers. The string key determines the name of the
  // query param, the provided value will be the value. This value is appended to any
  // value set to the :path header in `headers`.
  //
  // Interpolation is done in envoy rather than the control plane to prevent escaped
  // character issues. Additionally, we may be providing values not known until
  // the request is being executed (e.g., graphql parent info).
  map<string, string> query_params = 2;

  // Used to construct the outgoing body to the upstream from the
  // graphql value providers.
  google.protobuf.Value body = 3;
}

message ResponseTemplate {
  string result_root = 1;
  map<string, string> setters = 2;
}

// control-plane API
message RESTResolver {
  core.solo.io.ResourceRef upstream_ref = 1;
  // configuration used to compose the outgoing request to a REST API
  RequestTemplate request = 2;
  ResponseTemplate response = 3;
  string span_name = 4;
}

message QueryMatcher {
  message FieldMatcher {
    // Object type. For example, Query.
    string type = 1;
    // Field with in the object.
    string field = 2;
  }

  oneof match {
    FieldMatcher field_matcher = 1;
  }
}

// This is the resolver map for the schema.
// For each Type.Field, we can define a resolver.
// if a field does not have resolver, the default resolver will be used.
// the default resolver takes the field with the same name from the parent, and uses that value
// to resolve the field.
// if a field with the same name does not exist in the parent, null will be used.
message Resolution {
  // Match an object type and field
  QueryMatcher matcher = 1;
  // The resolver to use.
  oneof resolver {
    RESTResolver rest_resolver = 3;
  }
}

// Enterprise-Only: THIS FEATURE IS IN TECH PREVIEW. APIs are versioned as alpha and subject to change.
// User-facing CR config for resolving client requests to graphql schemas.
// Routes that have this config will execute graphql queries, and will not make it to the router filter. i.e. this
// filter will terminate the request for these routes.
// Note: while users can provide this configuration manually, the eventual UX will
// be to generate the Executable Schema CRs from other sources and just have users
// configure the routes to point to these schema CRs.
message GraphQLSchema {

  option (core.solo.io.resource).short_name = "gqls";
  option (core.solo.io.resource).plural_name = "graphql_schemas";

  // NamespacedStatuses indicates the validation status of this resource.
  // NamespacedStatuses is read-only by clients, and set by gloo during validation
  core.solo.io.NamespacedStatuses namespaced_statuses = 1 [(extproto.skip_hashing) = true];

  // Metadata contains the object metadata for this resource
  core.solo.io.Metadata metadata = 2;

  // Schema to use in string format.
  string schema = 3;
  // Do we enable introspection for the schema? general recommendation is to disable this for production
  // and hence it defaults to false.
  bool enable_introspection = 4;
  // The resolver map to use to resolve the schema.
  // Omitted fields will use the default resolver, which looks for a field with that name in the parent's object,
  // and errors if the field cannot be found.
  repeated Resolution resolutions = 5;
}
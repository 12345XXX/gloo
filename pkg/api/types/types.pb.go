// Code generated by protoc-gen-go.
// source: types.proto
// DO NOT EDIT!

/*
Package types is a generated protocol buffer package.

It is generated from these files:
	types.proto

It has these top-level messages:
	Config
	Route
	Matcher
	FunctionDestination
	UpstreamDestination
	Upstream
	Function
	VirtualHost
	SSLConfig
*/
package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/struct"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Config struct {
	Routes       []*Route       `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty"`
	Upstreams    []*Upstream    `protobuf:"bytes,2,rep,name=upstreams" json:"upstreams,omitempty"`
	VirtualHosts []*VirtualHost `protobuf:"bytes,3,rep,name=virtual_hosts,json=virtualHosts" json:"virtual_hosts,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Config) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *Config) GetUpstreams() []*Upstream {
	if m != nil {
		return m.Upstreams
	}
	return nil
}

func (m *Config) GetVirtualHosts() []*VirtualHost {
	if m != nil {
		return m.VirtualHosts
	}
	return nil
}

type Route struct {
	Matcher *Matcher `protobuf:"bytes,1,opt,name=matcher" json:"matcher,omitempty"`
	// Types that are valid to be assigned to Destination:
	//	*Route_FunctionName
	//	*Route_UpstreamDestination
	Destination isRoute_Destination                `protobuf_oneof:"destination"`
	Plugins     map[string]*google_protobuf.Struct `protobuf:"bytes,4,rep,name=plugins" json:"plugins,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isRoute_Destination interface {
	isRoute_Destination()
}

type Route_FunctionName struct {
	FunctionName *FunctionDestination `protobuf:"bytes,2,opt,name=function_name,json=functionName,oneof"`
}
type Route_UpstreamDestination struct {
	UpstreamDestination *UpstreamDestination `protobuf:"bytes,3,opt,name=upstream_destination,json=upstreamDestination,oneof"`
}

func (*Route_FunctionName) isRoute_Destination()        {}
func (*Route_UpstreamDestination) isRoute_Destination() {}

func (m *Route) GetDestination() isRoute_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *Route) GetMatcher() *Matcher {
	if m != nil {
		return m.Matcher
	}
	return nil
}

func (m *Route) GetFunctionName() *FunctionDestination {
	if x, ok := m.GetDestination().(*Route_FunctionName); ok {
		return x.FunctionName
	}
	return nil
}

func (m *Route) GetUpstreamDestination() *UpstreamDestination {
	if x, ok := m.GetDestination().(*Route_UpstreamDestination); ok {
		return x.UpstreamDestination
	}
	return nil
}

func (m *Route) GetPlugins() map[string]*google_protobuf.Struct {
	if m != nil {
		return m.Plugins
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Route) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Route_OneofMarshaler, _Route_OneofUnmarshaler, _Route_OneofSizer, []interface{}{
		(*Route_FunctionName)(nil),
		(*Route_UpstreamDestination)(nil),
	}
}

func _Route_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Route)
	// destination
	switch x := m.Destination.(type) {
	case *Route_FunctionName:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FunctionName); err != nil {
			return err
		}
	case *Route_UpstreamDestination:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UpstreamDestination); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Route.Destination has unexpected type %T", x)
	}
	return nil
}

func _Route_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Route)
	switch tag {
	case 2: // destination.function_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FunctionDestination)
		err := b.DecodeMessage(msg)
		m.Destination = &Route_FunctionName{msg}
		return true, err
	case 3: // destination.upstream_destination
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UpstreamDestination)
		err := b.DecodeMessage(msg)
		m.Destination = &Route_UpstreamDestination{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Route_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Route)
	// destination
	switch x := m.Destination.(type) {
	case *Route_FunctionName:
		s := proto.Size(x.FunctionName)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Route_UpstreamDestination:
		s := proto.Size(x.UpstreamDestination)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Matcher struct {
	// Types that are valid to be assigned to Path:
	//	*Matcher_Prefix
	//	*Matcher_Regex
	//	*Matcher_Exact
	Path        isMatcher_Path    `protobuf_oneof:"path"`
	Headers     map[string]string `protobuf:"bytes,4,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Verbs       []string          `protobuf:"bytes,5,rep,name=verbs" json:"verbs,omitempty"`
	VirtualHost string            `protobuf:"bytes,6,opt,name=virtual_host,json=virtualHost" json:"virtual_host,omitempty"`
}

func (m *Matcher) Reset()                    { *m = Matcher{} }
func (m *Matcher) String() string            { return proto.CompactTextString(m) }
func (*Matcher) ProtoMessage()               {}
func (*Matcher) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isMatcher_Path interface {
	isMatcher_Path()
}

type Matcher_Prefix struct {
	Prefix string `protobuf:"bytes,1,opt,name=prefix,oneof"`
}
type Matcher_Regex struct {
	Regex string `protobuf:"bytes,2,opt,name=regex,oneof"`
}
type Matcher_Exact struct {
	Exact string `protobuf:"bytes,3,opt,name=exact,oneof"`
}

func (*Matcher_Prefix) isMatcher_Path() {}
func (*Matcher_Regex) isMatcher_Path()  {}
func (*Matcher_Exact) isMatcher_Path()  {}

func (m *Matcher) GetPath() isMatcher_Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Matcher) GetPrefix() string {
	if x, ok := m.GetPath().(*Matcher_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *Matcher) GetRegex() string {
	if x, ok := m.GetPath().(*Matcher_Regex); ok {
		return x.Regex
	}
	return ""
}

func (m *Matcher) GetExact() string {
	if x, ok := m.GetPath().(*Matcher_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *Matcher) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Matcher) GetVerbs() []string {
	if m != nil {
		return m.Verbs
	}
	return nil
}

func (m *Matcher) GetVirtualHost() string {
	if m != nil {
		return m.VirtualHost
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Matcher) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Matcher_OneofMarshaler, _Matcher_OneofUnmarshaler, _Matcher_OneofSizer, []interface{}{
		(*Matcher_Prefix)(nil),
		(*Matcher_Regex)(nil),
		(*Matcher_Exact)(nil),
	}
}

func _Matcher_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Matcher)
	// path
	switch x := m.Path.(type) {
	case *Matcher_Prefix:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Prefix)
	case *Matcher_Regex:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Regex)
	case *Matcher_Exact:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Exact)
	case nil:
	default:
		return fmt.Errorf("Matcher.Path has unexpected type %T", x)
	}
	return nil
}

func _Matcher_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Matcher)
	switch tag {
	case 1: // path.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Path = &Matcher_Prefix{x}
		return true, err
	case 2: // path.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Path = &Matcher_Regex{x}
		return true, err
	case 3: // path.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Path = &Matcher_Exact{x}
		return true, err
	default:
		return false, nil
	}
}

func _Matcher_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Matcher)
	// path
	switch x := m.Path.(type) {
	case *Matcher_Prefix:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *Matcher_Regex:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case *Matcher_Exact:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type FunctionDestination struct {
	UpstreamName string `protobuf:"bytes,1,opt,name=upstream_name,json=upstreamName" json:"upstream_name,omitempty"`
	FunctionName string `protobuf:"bytes,2,opt,name=function_name,json=functionName" json:"function_name,omitempty"`
}

func (m *FunctionDestination) Reset()                    { *m = FunctionDestination{} }
func (m *FunctionDestination) String() string            { return proto.CompactTextString(m) }
func (*FunctionDestination) ProtoMessage()               {}
func (*FunctionDestination) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FunctionDestination) GetUpstreamName() string {
	if m != nil {
		return m.UpstreamName
	}
	return ""
}

func (m *FunctionDestination) GetFunctionName() string {
	if m != nil {
		return m.FunctionName
	}
	return ""
}

type UpstreamDestination struct {
	UpstreamName  string `protobuf:"bytes,1,opt,name=upstream_name,json=upstreamName" json:"upstream_name,omitempty"`
	RewritePrefix string `protobuf:"bytes,2,opt,name=rewrite_prefix,json=rewritePrefix" json:"rewrite_prefix,omitempty"`
}

func (m *UpstreamDestination) Reset()                    { *m = UpstreamDestination{} }
func (m *UpstreamDestination) String() string            { return proto.CompactTextString(m) }
func (*UpstreamDestination) ProtoMessage()               {}
func (*UpstreamDestination) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UpstreamDestination) GetUpstreamName() string {
	if m != nil {
		return m.UpstreamName
	}
	return ""
}

func (m *UpstreamDestination) GetRewritePrefix() string {
	if m != nil {
		return m.RewritePrefix
	}
	return ""
}

type Upstream struct {
	Name      string                  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type      string                  `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Spec      *google_protobuf.Struct `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Functions []*Function             `protobuf:"bytes,4,rep,name=functions" json:"functions,omitempty"`
}

func (m *Upstream) Reset()                    { *m = Upstream{} }
func (m *Upstream) String() string            { return proto.CompactTextString(m) }
func (*Upstream) ProtoMessage()               {}
func (*Upstream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Upstream) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Upstream) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Upstream) GetSpec() *google_protobuf.Struct {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Upstream) GetFunctions() []*Function {
	if m != nil {
		return m.Functions
	}
	return nil
}

type Function struct {
	Name string                  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Spec *google_protobuf.Struct `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
}

func (m *Function) Reset()                    { *m = Function{} }
func (m *Function) String() string            { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()               {}
func (*Function) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Function) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Function) GetSpec() *google_protobuf.Struct {
	if m != nil {
		return m.Spec
	}
	return nil
}

type VirtualHost struct {
	Domains   []string   `protobuf:"bytes,1,rep,name=domains" json:"domains,omitempty"`
	SslConfig *SSLConfig `protobuf:"bytes,2,opt,name=ssl_config,json=sslConfig" json:"ssl_config,omitempty"`
}

func (m *VirtualHost) Reset()                    { *m = VirtualHost{} }
func (m *VirtualHost) String() string            { return proto.CompactTextString(m) }
func (*VirtualHost) ProtoMessage()               {}
func (*VirtualHost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *VirtualHost) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *VirtualHost) GetSslConfig() *SSLConfig {
	if m != nil {
		return m.SslConfig
	}
	return nil
}

type SSLConfig struct {
	CaCertPath string `protobuf:"bytes,1,opt,name=ca_cert_path,json=caCertPath" json:"ca_cert_path,omitempty"`
}

func (m *SSLConfig) Reset()                    { *m = SSLConfig{} }
func (m *SSLConfig) String() string            { return proto.CompactTextString(m) }
func (*SSLConfig) ProtoMessage()               {}
func (*SSLConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SSLConfig) GetCaCertPath() string {
	if m != nil {
		return m.CaCertPath
	}
	return ""
}

func init() {
	proto.RegisterType((*Config)(nil), "Config")
	proto.RegisterType((*Route)(nil), "Route")
	proto.RegisterType((*Matcher)(nil), "Matcher")
	proto.RegisterType((*FunctionDestination)(nil), "FunctionDestination")
	proto.RegisterType((*UpstreamDestination)(nil), "UpstreamDestination")
	proto.RegisterType((*Upstream)(nil), "Upstream")
	proto.RegisterType((*Function)(nil), "Function")
	proto.RegisterType((*VirtualHost)(nil), "VirtualHost")
	proto.RegisterType((*SSLConfig)(nil), "SSLConfig")
}

func init() { proto.RegisterFile("types.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 615 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0x4b, 0x6f, 0xd3, 0x40,
	0x10, 0xae, 0xf3, 0x70, 0xea, 0xb1, 0x83, 0xd0, 0x26, 0x80, 0x55, 0x21, 0x14, 0x5c, 0x21, 0x8a,
	0x50, 0xb7, 0xa2, 0x5c, 0x50, 0xb9, 0x51, 0x40, 0x41, 0x3c, 0x54, 0x6d, 0x04, 0x57, 0x6b, 0xeb,
	0x6c, 0x12, 0x0b, 0xc7, 0xb6, 0x76, 0xd7, 0x21, 0x39, 0x22, 0x71, 0xe0, 0x97, 0xf1, 0xbb, 0x90,
	0xf7, 0x91, 0xb8, 0x22, 0x48, 0x70, 0x9b, 0xf9, 0x66, 0x3c, 0xb3, 0xdf, 0xcc, 0x37, 0x06, 0x5f,
	0x6e, 0x4a, 0x26, 0x70, 0xc9, 0x0b, 0x59, 0x1c, 0xdd, 0x9f, 0x17, 0xc5, 0x3c, 0x63, 0x67, 0xca,
	0xbb, 0xae, 0x66, 0x67, 0x42, 0xf2, 0x2a, 0x91, 0x3a, 0x1a, 0xfd, 0x70, 0xc0, 0xbd, 0x2c, 0xf2,
	0x59, 0x3a, 0x47, 0x0f, 0xc0, 0xe5, 0x45, 0x25, 0x99, 0x08, 0x9d, 0x51, 0xfb, 0xc4, 0x3f, 0x77,
	0x31, 0xa9, 0x5d, 0x62, 0x50, 0xf4, 0x18, 0xbc, 0xaa, 0x14, 0x92, 0x33, 0xba, 0x14, 0x61, 0x4b,
	0xa5, 0x78, 0xf8, 0xb3, 0x41, 0xc8, 0x2e, 0x86, 0x9e, 0x41, 0x7f, 0x95, 0x72, 0x59, 0xd1, 0x2c,
	0x5e, 0x14, 0x42, 0x8a, 0xb0, 0xad, 0x92, 0x03, 0xfc, 0x45, 0xa3, 0xe3, 0x42, 0x48, 0x12, 0xac,
	0x76, 0x8e, 0x88, 0x7e, 0xb5, 0xa0, 0xab, 0xba, 0xa1, 0x08, 0x7a, 0x4b, 0x2a, 0x93, 0x05, 0xe3,
	0xa1, 0x33, 0x72, 0x4e, 0xfc, 0xf3, 0x43, 0xfc, 0x51, 0xfb, 0xc4, 0x06, 0xd0, 0x4b, 0xe8, 0xcf,
	0xaa, 0x3c, 0x91, 0x69, 0x91, 0xc7, 0x39, 0x5d, 0xb2, 0xb0, 0xa5, 0x32, 0x87, 0xf8, 0xad, 0x41,
	0x5f, 0x33, 0x21, 0xd3, 0x9c, 0xd6, 0xe6, 0xf8, 0x80, 0x04, 0x36, 0xf9, 0x13, 0x5d, 0x32, 0xf4,
	0x0e, 0x86, 0xf6, 0xa9, 0xf1, 0x74, 0x97, 0x17, 0xb6, 0x4d, 0x0d, 0xcb, 0xe8, 0x66, 0x8d, 0x41,
	0xf5, 0x27, 0x8c, 0x4e, 0xa1, 0x57, 0x66, 0xd5, 0x3c, 0xcd, 0x45, 0xd8, 0x51, 0x14, 0x07, 0x7a,
	0x64, 0xf8, 0x4a, 0xa3, 0x6f, 0x72, 0xc9, 0x37, 0xc4, 0xe6, 0x1c, 0x4d, 0x20, 0x68, 0x06, 0xd0,
	0x6d, 0x68, 0x7f, 0x65, 0x1b, 0x45, 0xd3, 0x23, 0xb5, 0x89, 0x4e, 0xa1, 0xbb, 0xa2, 0x59, 0x65,
	0x09, 0xdd, 0xc3, 0x7a, 0x77, 0xd8, 0xee, 0x0e, 0x4f, 0xd4, 0xee, 0x88, 0xce, 0xba, 0x68, 0xbd,
	0x70, 0x5e, 0xf5, 0xc1, 0x6f, 0xb0, 0x88, 0xbe, 0xb7, 0xa0, 0x67, 0xe6, 0x85, 0x42, 0x70, 0x4b,
	0xce, 0x66, 0xe9, 0x5a, 0xb7, 0x18, 0x1f, 0x10, 0xe3, 0xa3, 0xbb, 0xd0, 0xe5, 0x6c, 0xce, 0xd6,
	0xaa, 0x4f, 0x1d, 0xd0, 0x6e, 0x8d, 0xb3, 0x35, 0x4d, 0xa4, 0x1a, 0x86, 0xc2, 0x95, 0x8b, 0xce,
	0xa0, 0xb7, 0x60, 0x74, 0xca, 0xb8, 0x25, 0x7a, 0xc7, 0x2e, 0x05, 0x8f, 0x35, 0x6e, 0xa8, 0x9a,
	0x2c, 0x34, 0x84, 0xee, 0x8a, 0xf1, 0x6b, 0x11, 0x76, 0x47, 0xed, 0x13, 0x8f, 0x68, 0x07, 0x3d,
	0x84, 0xa0, 0x29, 0x8c, 0xd0, 0x55, 0xcc, 0xfd, 0x86, 0x12, 0x8e, 0x2e, 0x20, 0x68, 0x56, 0xdc,
	0x33, 0xa3, 0x61, 0x73, 0x46, 0x5e, 0x73, 0x14, 0x2e, 0x74, 0x4a, 0x2a, 0x17, 0x51, 0x0c, 0x83,
	0x3d, 0x42, 0x40, 0xc7, 0xd0, 0xdf, 0x2e, 0x5e, 0xa9, 0x46, 0x17, 0x0d, 0x2c, 0xa8, 0xd4, 0x71,
	0xbc, 0x4f, 0x5a, 0xde, 0x4d, 0x09, 0x45, 0x14, 0x06, 0x7b, 0x54, 0xf2, 0x6f, 0x0d, 0x1e, 0xc1,
	0x2d, 0xce, 0xbe, 0xf1, 0x54, 0xb2, 0xd8, 0x2c, 0x47, 0x77, 0xe8, 0x1b, 0xf4, 0x4a, 0x81, 0xd1,
	0x4f, 0x07, 0x0e, 0x6d, 0x0f, 0x84, 0xa0, 0xd3, 0xa8, 0xa7, 0xec, 0x1a, 0xab, 0xaf, 0xdc, 0x7c,
	0xad, 0x6c, 0xf4, 0x14, 0x3a, 0xa2, 0x64, 0x89, 0x91, 0xf2, 0x5f, 0xd5, 0xa3, 0x92, 0xea, 0x73,
	0xb6, 0xa4, 0xec, 0x56, 0xbd, 0xed, 0x01, 0x91, 0x5d, 0x2c, 0x7a, 0x0f, 0x87, 0x16, 0xde, 0xfb,
	0x92, 0xff, 0xe9, 0x1a, 0x11, 0xf0, 0x1b, 0x7f, 0x01, 0x14, 0x42, 0x6f, 0x5a, 0x2c, 0x69, 0x7d,
	0x41, 0x8e, 0x52, 0x8a, 0x75, 0xd1, 0x13, 0x00, 0x21, 0xb2, 0x38, 0x51, 0xff, 0x26, 0x73, 0x0f,
	0x80, 0x27, 0x93, 0x0f, 0xfa, 0x6f, 0x45, 0x3c, 0x21, 0x32, 0x6d, 0x46, 0xa7, 0xe0, 0x6d, 0x71,
	0x34, 0x82, 0x20, 0xa1, 0x71, 0xc2, 0xb8, 0x8c, 0x6b, 0x31, 0x98, 0x97, 0x42, 0x42, 0x2f, 0x19,
	0x97, 0x57, 0x54, 0x2e, 0xae, 0x5d, 0xf5, 0xb2, 0xe7, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x53,
	0xa1, 0xe3, 0x70, 0x26, 0x05, 0x00, 0x00,
}
